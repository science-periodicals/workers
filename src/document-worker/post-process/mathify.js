import { mjpage } from 'mathjax-node-page';
import { JSDOM } from 'jsdom';

export default function mathify(ctx, callback) {
  const { doc, log } = ctx;
  let maths = Array.from(doc.querySelectorAll('math'));

  if (!maths.length) return callback(null);

  mjpage(
    `<!DOCTYPE html>\n${doc.documentElement.outerHTML}`,
    {
      format: 'MathML',
      MathJax: {
        SVG: {
          font: 'STIX-Web',
          useGlobalCache: false,
          undefinedFamily: '"Arial Unicode MS", Arial, sans-serif',
          Augment: {
            initSVG() {
              // console.log('INITING');
              if (this.config.font !== 'TeX') {
                this.Augment({
                  lookupChar_old: this.lookupChar,
                  lookupChar(variant, n) {
                    let char;
                    do {
                      char = this.lookupChar_old(variant, n);
                      if (char.id !== 'unknown') return char;
                      variant = VARIANT[variant.chain];
                    } while (variant);
                    return char;
                  }
                });

                let VARIANT = this.FONTDATA.VARIANT;
                VARIANT.bold.chain = 'normal';
                VARIANT.italic.chain = 'normal';
                VARIANT['bold-italic'].chain = 'bold';
                VARIANT['double-struck'].chain = 'normal';
                VARIANT.fraktur.chain = 'normal';
                VARIANT['bold-fraktur'].chain = 'bold';
                VARIANT.script.chain = 'normal';
                VARIANT['bold-script'].chain = 'bold';
                VARIANT['sans-serif'].chain = 'normal';
                VARIANT['bold-sans-serif'].chain = 'bold';
                VARIANT['sans-serif-italic'].chain = 'italic';
                VARIANT['sans-serif-bold-italic'].chain = 'bold-italic';
                VARIANT.monospace.chain = 'normal';
                VARIANT['-tex-caligraphic'].chain = 'normal';
                VARIANT['-tex-oldstyle'].chain = 'normal';
                VARIANT['-tex-caligraphic-bold'].chain = 'bold';
                VARIANT['-tex-oldstyle-bold'].chain = 'bold';
              }

              this.initSVG = () => {};
            }
          }
        }
      }
    },
    {
      svg: true,
      useGlobalCache: false
    },
    result => {
      try {
        var {
          window: { document }
        } = new JSDOM(result);
      } catch (err) {
        log.error(err);
        return callback(null);
      }

      // !! `doc` may have been constructed from a JSDOM version !== from the one we use here
      // => we create a div with the JSOM version used by `doc` to circumvent that issue
      // Note: setting the outerHTML of SVG is not supported yet so we don't rely on that simpler approach
      const div = doc.createElement('div');
      div.innerHTML = document.body.innerHTML;

      Array.from(div.querySelectorAll('span.mjpage')).forEach(
        (mathSpan, idx) => {
          let mel = maths[idx];
          let span = doc.createElement('span');
          let spanStyle = [];

          // if the mathSpan generated by MJ has a parent with .MathJax_SVG_Display then it's a
          // block, otherwise it's inline
          if (mathSpan.classList.contains('mjpage__block')) {
            spanStyle.push('display: block');
          } else {
            spanStyle.push('display: inline-block');
            spanStyle.push('line-height: 1');
          }

          span.setAttribute('role', 'math');
          span.appendChild(mel.cloneNode(true));

          let svg = mathSpan.querySelector('svg');
          if (svg) {
            svg.setAttribute('aria-hidden', 'true');
            span.appendChild(svg);

            let rawHeight = svg.getAttribute('height');
            let h = parseFloat(rawHeight || '0');
            let vb = (svg.getAttribute('viewBox') || '')
              .split(/\s+/)
              .map(parseFloat);

            if (h || vb.length) {
              // vertical-align = -(vb-height + vb-y) / (vb-height / height)
              let va = -(vb[3] + vb[1]) / (vb[3] / h);
              spanStyle.push(`vertical-align: ${va}ex`);
              if (rawHeight) {
                spanStyle.push(`height: ${rawHeight}`);
              }
            }
          }

          // Note: we used `data-style` instead of `style` so it doesn't get
          // cleaned up. `data-style` will be turn into `style` further downstream
          // (post cleanup).
          span.setAttribute('data-style', spanStyle.join('; '));

          mel.parentNode.replaceChild(span, mel);
        }
      );

      callback(null);
    }
  );
}

mathify.message = `Typesetting mathematics`;
